import fs from 'fs/promises';

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/zodUtils.ts
var toPrettyZodErrors = (error) => {
  return error.issues.map((issue) => `${issue.path.join(".")}: ${issue.message}`);
};
var toPrettyZodError = (error) => {
  return `Zod validation error: ${error.message}
${toPrettyZodErrors(error).join("\n")}`;
};

// src/Dotenv.ts
var defaultLogger = {
  info: (message, ctx) => {
    console.log(message, ctx);
  },
  error: (message, ctx) => {
    console.error(message, ctx);
  }
};
var Dotenv = class _Dotenv {
  /**
   * Creates a new Dotenv instance.
   * @param options - Configuration options for the Dotenv instance
   */
  constructor(options) {
    this.parsedValues = {};
    var _a, _b;
    this.logger = (_a = options.logger) != null ? _a : defaultLogger;
    this.coerceValues = (_b = options.coerceValues) != null ? _b : false;
  }
  /**
   * Loads environment variables from a single .env file.
   * @param filepath - Path to the .env file to load
   */
  load(filepath) {
    return __async(this, null, function* () {
      this.logger.info(`Loading environment variables from ${filepath}`);
      try {
        const envFile = yield fs.readFile(filepath, "utf8");
        const envVars = this.parseEnvFile(envFile);
        for (const [key, value] of Object.entries(envVars)) {
          process.env[key] = String(value);
          this.parsedValues[key] = value;
        }
      } catch (error) {
        this.logger.error(
          `Failed to load environment variables from ${filepath}: ${error instanceof Error ? error.message : String(error)}`
        );
        throw error;
      }
    });
  }
  parseEnvFile(content) {
    const envVars = {};
    const lines = content.split("\n");
    let currentKey = null;
    let currentValue = [];
    let inMultiline = false;
    let wasMultiline = false;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const trimmedLine = line.trim();
      if (trimmedLine.startsWith("#")) {
        continue;
      }
      if (!trimmedLine && !inMultiline) {
        continue;
      }
      const equalsIndex = line.indexOf("=");
      if (equalsIndex !== -1 && !inMultiline) {
        if (currentKey && currentValue.length > 0) {
          const rawValue = wasMultiline ? this.unescapeString(currentValue.join("\n")) : this.processValue(currentValue.join("\n"));
          envVars[currentKey] = this.coerceValues ? this.coerceValue(rawValue) : rawValue;
        }
        currentKey = line.substring(0, equalsIndex).trim();
        const valueStart = line.substring(equalsIndex + 1);
        if (valueStart.startsWith('"""')) {
          inMultiline = true;
          wasMultiline = true;
          const afterQuotes = valueStart.substring(3);
          currentValue = afterQuotes ? [afterQuotes] : [];
        } else if (valueStart.startsWith('"')) {
          if (this.hasClosingQuote(valueStart)) {
            currentValue = [valueStart];
            inMultiline = false;
            wasMultiline = false;
          } else {
            currentValue = [valueStart];
            inMultiline = false;
            wasMultiline = false;
          }
        } else {
          currentValue = [valueStart];
          inMultiline = false;
          wasMultiline = false;
        }
      } else if (inMultiline && currentKey) {
        currentValue.push(line);
        const lastLine = currentValue[currentValue.length - 1];
        if (this.hasClosingTripleQuotes(lastLine)) {
          const trimmedLastLine = lastLine.substring(0, lastLine.length - 3);
          currentValue[currentValue.length - 1] = trimmedLastLine;
          inMultiline = false;
        }
      } else if (currentKey) {
        currentValue.push(line);
      }
    }
    if (currentKey && currentValue.length > 0) {
      const rawValue = wasMultiline ? this.unescapeString(currentValue.join("\n")) : this.processValue(currentValue.join("\n"));
      envVars[currentKey] = this.coerceValues ? this.coerceValue(rawValue) : rawValue;
    }
    return envVars;
  }
  processValue(value) {
    if (value.startsWith('"""') && value.endsWith('"""')) {
      const unquoted = value.slice(3, -3);
      return this.unescapeString(unquoted);
    }
    if (value.startsWith('"') && value.endsWith('"')) {
      const unquoted = value.slice(1, -1);
      return this.unescapeString(unquoted);
    }
    return value.trim();
  }
  coerceValue(value) {
    const trimmed = value.trim();
    if (trimmed.startsWith("{") || trimmed.startsWith("[")) {
      try {
        return JSON.parse(trimmed);
      } catch (e) {
      }
    }
    if (trimmed.toLowerCase() === "true") {
      return true;
    }
    if (trimmed.toLowerCase() === "false") {
      return false;
    }
    if (trimmed.toLowerCase() === "null") {
      return null;
    }
    if (!isNaN(Number(trimmed)) && trimmed !== "") {
      const num = Number(trimmed);
      if (!isNaN(num) && (trimmed !== "" || num !== 0)) {
        return num;
      }
    }
    return value;
  }
  hasClosingQuote(line) {
    for (let i = line.length - 1; i >= 0; i--) {
      if (line[i] === '"') {
        if (i === 0 || line[i - 1] !== "\\") {
          return true;
        }
      }
    }
    return false;
  }
  hasClosingTripleQuotes(line) {
    return line.trim().endsWith('"""');
  }
  unescapeString(value) {
    return value.replace(/\\"/g, '"');
  }
  /**
   * Initializes the Dotenv instance by loading files and optionally validating with a schema.
   * @param options - Configuration options for initialization
   */
  initialize(options) {
    return __async(this, null, function* () {
      var _a;
      if (options.filepaths) {
        for (const filepath of options.filepaths) {
          yield this.load(filepath != null ? filepath : ".env");
        }
      }
      const profiles = (_a = process.env.PROFILES) == null ? void 0 : _a.split(",").map((profile) => profile.trim()).filter((profile) => profile.length > 0);
      if (profiles && profiles.length > 0) {
        this.logger.info(`Loading profiles: PROFILES=${profiles.join(",")}`);
        for (const profile of profiles) {
          yield this.load(`.env.${profile}`);
        }
      }
      if (options.schema) {
        this.logger.info("Validating environment variables");
        this.get(options.schema);
      }
    });
  }
  /**
   * Validates and returns environment variables using a Zod schema.
   * @param schema - Zod schema to validate environment variables against
   * @returns Validated configuration object
   * @throws Error if validation fails
   */
  get(schema) {
    const envData = this.coerceValues ? this.parsedValues : process.env;
    const result = schema.safeParse(envData);
    if (!result.success) {
      this.logger.error(toPrettyZodError(result.error), {
        cause: result.error,
        env: envData
      });
      throw new Error(toPrettyZodError(result.error));
    }
    return result.data;
  }
  /**
   * Creates and configures a Dotenv instance.
   * @param options - Configuration options
   * @returns Configured Dotenv instance
   */
  static configure(options) {
    return __async(this, null, function* () {
      const dotenv = new _Dotenv(options);
      yield dotenv.initialize(options);
      return dotenv;
    });
  }
  /**
   * Loads and validates environment variables in one step.
   * @param options - Load options including schema for validation
   * @returns Validated configuration object
   */
  static load(options) {
    return __async(this, null, function* () {
      const dotenv = new _Dotenv(options);
      yield dotenv.initialize(options);
      return dotenv.get(options.schema);
    });
  }
};

export { Dotenv };
//# sourceMappingURL=index.mjs.map
//# sourceMappingURL=index.mjs.map